#import "libc.kai"

instructionSizes := [256]u8 {
	1, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	3, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	1, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	1, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 0, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 0, 3, 0, 0,
	2, 2, 2, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
}

instructionModes := [256]u8 {
	6, 7, 6, 7, 11, 11, 11, 11, 6, 5, 4, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
	1, 7, 6, 7, 11, 11, 11, 11, 6, 5, 4, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
	6, 7, 6, 7, 11, 11, 11, 11, 6, 5, 4, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
	6, 7, 6, 7, 11, 11, 11, 11, 6, 5, 4, 5, 8, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
	5, 7, 5, 7, 11, 11, 11, 11, 6, 5, 6, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 13, 13, 6, 3, 6, 3, 2, 2, 3, 3,
	5, 7, 5, 7, 11, 11, 11, 11, 6, 5, 6, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 13, 13, 6, 3, 6, 3, 2, 2, 3, 3,
	5, 7, 5, 7, 11, 11, 11, 11, 6, 5, 6, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
	5, 7, 5, 7, 11, 11, 11, 11, 6, 5, 6, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
}

instructionCycles := [256]u8 {
	7, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 4, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
	6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 4, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
	6, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 3, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
	6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 5, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
	2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,
	2, 6, 2, 6, 4, 4, 4, 4, 2, 5, 2, 5, 5, 5, 5, 5,
	2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,
	2, 5, 2, 5, 4, 4, 4, 4, 2, 4, 2, 4, 4, 4, 4, 4,
	2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
	2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
}

instructionPageCycles := [256]u8 {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
}

/*
instrTable :: [256]() -> void {
    brk, ora, kil, slo, nop, ora, asl, slo,
    php, ora, asl, anc, nop, ora, asl, slo,
    bpl, ora, kil, slo, nop, ora, asl, slo,
    clc, ora, nop, slo, nop, ora, asl, slo,
    jsr, and, kil, rla, bit, and, rol, rla,
    plp, and, rol, anc, bit, and, rol, rla,
    bmi, and, kil, rla, nop, and, rol, rla,
    sec, and, nop, rla, nop, and, rol, rla,
    rti, eor, kil, sre, nop, eor, lsr, sre,
    pha, eor, lsr, alr, jmp, eor, lsr, sre,
    bvc, eor, kil, sre, nop, eor, lsr, sre,
    cli, eor, nop, sre, nop, eor, lsr, sre,
    rts, adc, kil, rra, nop, adc, ror, rra,
    pla, adc, ror, arr, jmp, adc, ror, rra,
    bvs, adc, kil, rra, nop, adc, ror, rra,
    sei, adc, nop, rra, nop, adc, ror, rra,
    nop, sta, nop, sax, sty, sta, stx, sax,
    dey, nop, txa, xaa, sty, sta, stx, sax,
    bcc, sta, kil, ahx, sty, sta, stx, sax,
    tya, sta, txs, tas, shy, sta, shx, ahx,
    ldy, lda, ldx, lax, ldy, lda, ldx, lax,
    tay, lda, tax, lax, ldy, lda, ldx, lax,
    bcs, lda, kil, lax, ldy, lda, ldx, lax,
    clv, lda, tsx, las, ldy, lda, ldx, lax,
    cpy, cmp, nop, dcp, cpy, cmp, dec, dcp,
    iny, cmp, dex, axs, cpy, cmp, dec, dcp,
    bne, cmp, kil, dcp, nop, cmp, dec, dcp,
    cld, cmp, nop, dcp, nop, cmp, dec, dcp,
    cpx, sbc, nop, isc, cpx, sbc, inc, isc,
    inx, sbc, nop, sbc, cpx, sbc, inc, isc,
    beq, sbc, kil, isc, nop, sbc, inc, isc,
    sed, sbc, nop, isc, nop, sbc, inc, isc
}
*/

Mode :: enum(u8) {
    absolute = 1,
    absoluteX,
    absoluteY,
    accumulator,
    immediate,
    implied,
    indexedIndirect,
    indirect,
    indirectIndexed,
    relative,
    zeroPage,
    zeroPageX,
    zeroPageY 
}

CPU :: struct {
    a, x, y, sp, p: u8,
    pc: u16,
    stall: i32,
    cycles: u64
}

Step :: struct {
    address: u16,
    pc: u16,
    mode: u8
}

calcAddress :: fn(msb, lsb: u8) -> u16 {
    m := cast(u16)msb
    l := cast(u16)lsb
    return m * 0x100 + l
}

boot :: fn() -> CPU {
    cpu: CPU
    cpu.a, cpu.x, cpu.y = 0, 0, 0
    cpu.sp = 0xFD
    cpu.p = 0x24
    cpu.pc = 0xC000

    /* TODO
        - $4017: 0 (frame irq disabled)
        - $4015: 0 (sound channels disabled)
        - $4000-$400F: 0 (sound registers)
    */

    return cpu
}

readMem :: fn(address: u16, ram, pgrRom: []u8) -> u8 {
    return 0
}


step :: fn(cpu: CPU, ram: []u8, pgrRom: []u8, isRunning: *bool) -> CPU {
    instr := readMem(cpu.pc, ram, pgrRom)
    index := cast(i64)instr

    mode : Mode = <(bitcast(*Mode) &instructionModes[index])

    address: u16
    pageCrossed := false
    switch mode {
    case Mode.absolute:
        break
    case Mode.absoluteX:
        break
    case Mode.absoluteY:
        break
    case Mode.accumulator:
        address = 0
    case Mode.immediate:
        address = cpu.pc + 1
    case Mode.implied:
        address = 0
    case Mode.indexedIndirect:
        break
    case Mode.indirect:
        break
    case Mode.indirectIndexed:
        break
    case Mode.relative:
        break
    case Mode.zeroPage:
        break
    case Mode.zeroPageX:
        break
    case Mode.zeroPageY:
        break
    case: break
    }

    cpu.pc += cast(u16) instructionSizes[index]
    oldCycles := cpu.cycles
    cpu.cycles += cast(u64) instructionCycles[index]
    if pageCrossed
        cpu.cycles += cast(u64) instructionPageCycles[index]

    <isRunning = false
    return cpu
}

adc :: fn(cpu: CPU, step: Step) -> CPU {
    return cpu
}
