#import "libc.kai"
#import "memory.kai"

Memory :: memory.Memory

instructionSizes := [256]u8 {
	1, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	3, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	1, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	1, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 0, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 0, 3, 0, 0,
	2, 2, 2, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
}

instructionModes := [256]u8 {
	6, 7, 6, 7, 11, 11, 11, 11, 6, 5, 4, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
	1, 7, 6, 7, 11, 11, 11, 11, 6, 5, 4, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
	6, 7, 6, 7, 11, 11, 11, 11, 6, 5, 4, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
	6, 7, 6, 7, 11, 11, 11, 11, 6, 5, 4, 5, 8, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
	5, 7, 5, 7, 11, 11, 11, 11, 6, 5, 6, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 13, 13, 6, 3, 6, 3, 2, 2, 3, 3,
	5, 7, 5, 7, 11, 11, 11, 11, 6, 5, 6, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 13, 13, 6, 3, 6, 3, 2, 2, 3, 3,
	5, 7, 5, 7, 11, 11, 11, 11, 6, 5, 6, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
	5, 7, 5, 7, 11, 11, 11, 11, 6, 5, 6, 5, 1, 1, 1, 1,
	10, 9, 6, 9, 12, 12, 12, 12, 6, 3, 6, 3, 2, 2, 2, 2,
}

instructionCycles := [256]u8 {
	7, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 4, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
	6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 4, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
	6, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 3, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
	6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 5, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
	2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,
	2, 6, 2, 6, 4, 4, 4, 4, 2, 5, 2, 5, 5, 5, 5, 5,
	2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,
	2, 5, 2, 5, 4, 4, 4, 4, 2, 4, 2, 4, 4, 4, 4, 4,
	2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
	2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,
	2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,
}

instructionPageCycles := [256]u8 {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
}

/*
instrTable :: [256]() -> void {
    brk, ora, kil, slo, nop, ora, asl, slo,
    php, ora, asl, anc, nop, ora, asl, slo,
    bpl, ora, kil, slo, nop, ora, asl, slo,
    clc, ora, nop, slo, nop, ora, asl, slo,
    jsr, and, kil, rla, bit, and, rol, rla,
    plp, and, rol, anc, bit, and, rol, rla,
    bmi, and, kil, rla, nop, and, rol, rla,
    sec, and, nop, rla, nop, and, rol, rla,
    rti, eor, kil, sre, nop, eor, lsr, sre,
    pha, eor, lsr, alr, jmp, eor, lsr, sre,
    bvc, eor, kil, sre, nop, eor, lsr, sre,
    cli, eor, nop, sre, nop, eor, lsr, sre,
    rts, adc, kil, rra, nop, adc, ror, rra,
    pla, adc, ror, arr, jmp, adc, ror, rra,
    bvs, adc, kil, rra, nop, adc, ror, rra,
    sei, adc, nop, rra, nop, adc, ror, rra,
    nop, sta, nop, sax, sty, sta, stx, sax,
    dey, nop, txa, xaa, sty, sta, stx, sax,
    bcc, sta, kil, ahx, sty, sta, stx, sax,
    tya, sta, txs, tas, shy, sta, shx, ahx,
    ldy, lda, ldx, lax, ldy, lda, ldx, lax,
    tay, lda, tax, lax, ldy, lda, ldx, lax,
    bcs, lda, kil, lax, ldy, lda, ldx, lax,
    clv, lda, tsx, las, ldy, lda, ldx, lax,
    cpy, cmp, nop, dcp, cpy, cmp, dec, dcp,
    iny, cmp, dex, axs, cpy, cmp, dec, dcp,
    bne, cmp, kil, dcp, nop, cmp, dec, dcp,
    cld, cmp, nop, dcp, nop, cmp, dec, dcp,
    cpx, sbc, nop, isc, cpx, sbc, inc, isc,
    inx, sbc, nop, sbc, cpx, sbc, inc, isc,
    beq, sbc, kil, isc, nop, sbc, inc, isc,
    sed, sbc, nop, isc, nop, sbc, inc, isc
}
*/

Mode :: enum(u8) {
    absolute = 1,
    absoluteX,
    absoluteY,
    accumulator,
    immediate,
    implied,
    indexedIndirect,
    indirect,
    indirectIndexed,
    relative,
    zeroPage,
    zeroPageX,
    zeroPageY 
}

CPU :: struct {
    a, x, y, sp: u8,
    C, Z, I, D, B, U, V, N: u8,
    pc: u16,
    stall: i32,
    cycles: u64,
    mem: *Memory
}

Step :: struct {
    address: u16,
    pc: u16,
    mode: u8
}

calcAddress :: fn(msb, lsb: u8) -> u16 {
    m := cast(u16)msb
    l := cast(u16)lsb
    return m * 0x100 + l
}

boot :: fn(mem: *Memory) -> CPU {
    cpu: CPU
    cpu.mem = mem
    cpu.a, cpu.x, cpu.y = 0, 0, 0
    cpu.sp = 0xFD
    cpu.pc = 0xC000

    /* TODO
        - $4017: 0 (frame irq disabled)
        - $4015: 0 (sound channels disabled)
        - $4000-$400F: 0 (sound registers)
    */

    return cpu
}

read :: fn(address: u16, mem: *Memory) -> u8 {
    m := <mem
    if address < 0x2000
        return m.ram[address % 0x0800]
    else if address < 0x4000
        return 0 // TODO: read PPU register
    else if address == 0x4014
        return 0 // TODO: read PPU register
    else if address == 0x4015
        return 0 // TODO: read APU register
    else if address == 0x4016
        return 0 // TODO: read controller 1
    else if address == 0x4017
        return 0 // TODO: read controller 2
    else if address < 0x6000
        return 0 // TODO: read I/O registers
    else if address >= 0x6000
        return m.mapper.read(address)

    return 0
}

read16 :: fn(address: u16, mem: *Memory) -> u16 {
    lo := cast(u16)read(address, mem)
    hi := cast(u16)read(address, mem)
    return hi << 8 | lo
}

read16Bugged :: fn(address: u16, mem: *Memory) -> u16 {
    a := address
    aTrunc := cast(u8)a
    aTrunc += 1
    a = cast(u16)aTrunc
    b := (a & 0xFF00) | a
    lo := read(a, mem)
    hi := read(b, mem)

    lo16 := cast(u16)lo
    hi16 := cast(u16)hi
    return hi16 << 8 | lo16
}

flags :: fn(cpu: CPU) -> u8 {
    res: u8 = 0
    res |= cpu.C << 0
    res |= cpu.Z << 1
    res |= cpu.I << 2
    res |= cpu.D << 3
    res |= cpu.B << 4
    res |= cpu.U << 5
    res |= cpu.V << 6
    res |= cpu.N << 7
    return res
}

setFlags :: fn(cpu: CPU, flags: u8) -> CPU {
    cpu.C = (flags >> 0) & 1
    cpu.Z = (flags >> 1) & 1
    cpu.I = (flags >> 2) & 1
    cpu.D = (flags >> 3) & 1
    cpu.B = (flags >> 4) & 1
    cpu.U = (flags >> 5) & 1
    cpu.V = (flags >> 6) & 1
    cpu.N = (flags >> 7) & 1
    return cpu
}

setZ :: fn(cpu: CPU, val: u8) -> CPU {
    if val == 0
        cpu.Z = 1
    else
        cpu.Z = 0
    return cpu
}

setN :: fn(cpu: CPU, val: u8) -> CPU {
    if val & 0x80 != 0
        cpu.N = 1
    else
        cpu.N = 0
    return cpu
}

setZN :: fn(cpu: CPU, val: u8) -> CPU {
    cpu = setZ(cpu, val)
    cpu = setN(cpu, val)
    return cpu
}

step :: fn(cpu: CPU, isRunning: *bool) -> CPU {
    instr := read(cpu.pc, cpu.mem)
    index := cast(i64)instr

    mode : Mode = <(bitcast(*Mode) &instructionModes[index])

    address: u16
    pageCrossed := false
    switch mode {
    case Mode.absolute:
        break
    case Mode.absoluteX:
        break
    case Mode.absoluteY:
        break
    case Mode.accumulator:
        address = 0
    case Mode.immediate:
        address = cpu.pc + 1
    case Mode.implied:
        address = 0
    case Mode.indexedIndirect:
        break
    case Mode.indirect:
        break
    case Mode.indirectIndexed:
        break
    case Mode.relative:
        break
    case Mode.zeroPage:
        break
    case Mode.zeroPageX:
        break
    case Mode.zeroPageY:
        break
    case: break
    }

    cpu.pc += cast(u16) instructionSizes[index]
    oldCycles := cpu.cycles
    cpu.cycles += cast(u64) instructionCycles[index]
    if pageCrossed
        cpu.cycles += cast(u64) instructionPageCycles[index]

    <isRunning = false
    return cpu
}

adc :: fn(cpu: CPU, step: Step) -> CPU {
    return cpu
}
