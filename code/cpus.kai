#import "libc.kai"

ADC  :: 0x69
SBC  :: 0xE9

LDA  :: 0xA9
LDX  :: 0xA2
LDY  :: 0xA0

STA  :: 0x85
STX  :: 0x86

INX  :: 0xE8
INY  :: 0xC8

JMP  :: 0x4C
JMPi :: 0x6C
JSR  :: 0x20

BPL  :: 0x10
BMI  :: 0x30
BVC  :: 0x50
BVS  :: 0x70
BCC  :: 0x90
BCS  :: 0xB0
BNE  :: 0xD0
BEQ  :: 0xF0

RTS  :: 0x60

CLC  :: 0x18
SEC  :: 0x38
CLI  :: 0x58
SEI  :: 0x78
CLV  :: 0xB8
CLD  :: 0xD8
SED  :: 0xF8

PHA  :: 0x48
PLA  :: 0x68
PHP  :: 0x08
PLP  :: 0x28

CMP  :: 0xC9
CPX  :: 0xE0
CPY  :: 0xC0

AND  :: 0x29

BIT  :: 0x24

NOP  :: 0xEA

ORA  :: 0x09
EOR  :: 0x49

instructionSizes := [256]u8 {
	1, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	3, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	1, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	1, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 0, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 0, 3, 0, 0,
	2, 2, 2, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 2, 1, 0, 3, 3, 3, 0,
	2, 2, 0, 0, 2, 2, 2, 0, 1, 3, 1, 0, 3, 3, 3, 0,
}

CPU :: struct {
    a, x, y, sp, p: u8,
    pc: u16
}

calcAddress :: fn(msb, lsb: u8) -> u16 {
    m := cast(u16)msb
    l := cast(u16)lsb
    return m * 0x100 + l
}

boot :: fn() -> CPU {
    cpu: CPU
    cpu.a, cpu.x, cpu.y = 0, 0, 0
    cpu.sp = 0xFD
    cpu.p = 0x24
    cpu.pc = 0xC000

    /* TODO
        - $4017: 0 (frame irq disabled)
        - $4015: 0 (sound channels disabled)
        - $4000-$400F: 0 (sound registers)
    */

    return cpu
}

getInstr :: fn(address: u16, ram, pgrRom: []u8) -> u8, []u8 {
    buff : []u8

    if address >= 0x00 && address <= 0x1FFF {
        buff = ram
    }

    if address >= 0xc000 {
        address -= 0xc000 
        buff = pgrRom
    }

    index := cast(i64)address
    return buff[index], buff[index+1:]
}

step :: fn(cpu: CPU, ram: []u8, pgrRom: []u8, lastInst: *u8, isRunning: *bool) -> CPU {
    instr, buff := getInstr(cpu.pc, ram, pgrRom)
    <lastInst = instr

    cpu.pc += instructionSizes[cast(u16)instr]

    switch instr {
    case ADC:
        val := cpu.a + buff[0]
        val16Bit : u16 = cast(u16)cpu.a + buff[0]

        if cpu.p & 0x01 > 0 {
            val += 1
            val16Bit += 1
        }
       
        // if the signs don't match report an overflow 
        if ((cpu.a ^ val) & (buff[0] ^ val) & 0x80) > 0 
            cpu.p |= 0x40
        else
            cpu.p &= 0xBF

        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

        if val16Bit & 0x100 > 0
            cpu.p |= 0x01
        else
            cpu.p &= 0xFE

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F
        
        cpu.a = val

    case SBC:
        val := cpu.a - buff[0]
        val16Bit : i16 = cast(i16)cpu.a - buff[0]

        if cpu.p & 0x01 == 0 {
            val -= 1
            val16Bit -= 1
        }
       
        // if the signs don't match report an overflow 
        if (cpu.a ^ buff[0]) & 0x80 != 0 && (cpu.a ^ val) & 0x80 != 0
            cpu.p |= 0x40
        else
            cpu.p &= 0xBF

        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

        libc.printf("CARRY: a:%X, b: %X, v: %X, v16: %d\n".raw, cpu.a, buff[0], val, val16Bit)
        if val16Bit >= 0
            cpu.p |= 0x01
        else
            cpu.p &= 0xFE

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F
        
        cpu.a = val

    case LDA:
        cpu.a = buff[0]
        if cpu.a == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

        if cpu.a & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F

    case LDX:
        cpu.x = buff[0]
        if cpu.x == 0
            cpu.p |=  0x02
        else
            cpu.p &= 0xFD

        if cpu.x & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F

    case LDY:
        val := buff[0]
        cpu.y = val
        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F

    case STA:
        ram[buff[0]] = cpu.a

    case STX:
        ram[buff[0]] = cpu.x

    case INX:
        val := cpu.x + 1
        cpu.x = val
        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F
    case INY:
        val := cpu.y + 1
        cpu.y = val
        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F

    case JMP:
        add := buff[:2]
        cpu.pc = calcAddress(add[1], add[0]) 

    case JSR:
        b := buff[:2]
        // store 'pc' to stack to restore later
        pc := cpu.pc - 1
        high := cast(u8)(pc >> 8)
        low  := cast(u8)(pc & 0xFF) 

        ram[0x100 + cpu.sp] = high
        ram[0x100 + cpu.sp - 1] = low

        cpu.sp -= 2
        cpu.pc = calcAddress(b[1], b[0])

    case BPL:
        if cpu.p & 0x80 == 0 {
            rel := cast(u16)buff[0]
            cpu.pc += rel
        }

    case BMI:
        if cpu.p & 0x80 > 0 {
            rel := cast(u16)buff[0]
            cpu.pc += rel
        }

    case BVC:
        if cpu.p & 0x40 == 0 {
            rel := cast(u16)buff[0]
            cpu.pc += rel
        }

    case BVS:
        if cpu.p & 0x40 > 0 {
            rel := cast(u16)buff[0]
            cpu.pc += rel
        }

    case BCC:
        if cpu.p & 0x01 == 0 {
            rel := cast(u16)buff[0]
            cpu.pc += rel
        }

    case BCS:
        if cpu.p & 0x01 > 0 {
            rel := cast(u16)buff[0]
            cpu.pc += rel
        }

    case BNE:
        if cpu.p & 0x02 == 0 {
            rel := cast(u16)buff[0]
            cpu.pc += rel
        }

    case BEQ:
        if cpu.p & 0x02 > 0 {
            rel := cast(u16)buff[0]
            cpu.pc += rel
        }

    case RTS:
        low  := ram[0x100 + cpu.sp + 1]
        high := ram[0x100 + cpu.sp + 2]
        a := calcAddress(high, low) 
        cpu.pc = a + 1
        cpu.sp += 2

    case CLC:
        cpu.p &= 0xFE

    case SEC:
        cpu.p |= 0x01

    case CLI:
        cpu.p &= 0xFB 

    case SEI:
        cpu.p |= 0x04

    case CLV:
        cpu.p &= 0xBF

    case CLD:
        cpu.p &= 0xF7

    case SED:
        cpu.p |= 0x08

    case PHA:
        ram[0x100 + cpu.sp] = cpu.a
        cpu.sp -= 1

    case PLA:
        cpu.sp += 1
        val := ram[0x100 + cpu.sp]
        cpu.a = val

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F

        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

    case PHP:

        // ..two instructions (PHP and BRK) push the flags to the stack. In the
        // byte pushed, bit 5 is always set to 1, and bit 4 is 1 if from an 
        // instruction (PHP or BRK)
        p := cpu.p
        p |= 0x10
        p |= 0x20

        ram[0x100 + cpu.sp] = p
        cpu.sp -= 1
        
    case PLP:
        cpu.sp += 1
        fourFiveMask := cpu.p & 0x30
        val := ram[0x100 + cpu.sp]
        val &= 0xCF // disable bits 4 & 5
        cpu.p = val | fourFiveMask

    case CMP:
        M := buff[0]
        val := cpu.a - M
        
        if cpu.a >= M
            cpu.p |= 0x01
        else
            cpu.p &= 0xFE

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F
    
        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

    case CPX:
        M := buff[0]
        val := cpu.x - M
        
        if cpu.x >= M
            cpu.p |= 0x01
        else
            cpu.p &= 0xFE

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F
    
        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

    case CPY:
        M := buff[0]
        val := cpu.y - M
        
        if cpu.y >= M
            cpu.p |= 0x01
        else
            cpu.p &= 0xFE

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F
    
        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

    case AND:
        val := buff[0] & cpu.a
        cpu.a = val

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F

        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

    case BIT:
        val := ram[buff[0]]
        if val & cpu.a == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD 

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F

        if val & 0x40 > 0
            cpu.p |= 0x40
        else
            cpu.p &= 0xBF

    case NOP:
        break

    case ORA:
        val := cpu.a | buff[0]
        cpu.a = val
        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F

    case EOR:
        val := cpu.a ^ buff[0]
        cpu.a = val
        if val == 0
            cpu.p |= 0x02
        else
            cpu.p &= 0xFD

        if val & 0x80 > 0
            cpu.p |= 0x80
        else
            cpu.p &= 0x7F

    case:
        <isRunning = false
    }

    return cpu
}

